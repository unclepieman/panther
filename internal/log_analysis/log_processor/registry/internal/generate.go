package internal

/**
 * Panther is a Cloud-Native SIEM for the Modern Security Team.
 * Copyright (C) 2020 Panther Labs Inc
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

import (
	"bytes"
	"go/types"
	"text/template"

	"golang.org/x/tools/go/packages"
)

const (
	exportFuncName        = "LogTypes"
	typeNameLogTypesGroup = "Group"
	pkgPathLogTypes       = "github.com/panther-labs/panther/internal/log_analysis/log_processor/logtypes"
	pkgNameLogTypes       = "logtypes"
)

// LoadExportedLogTypes scans packages for exported log types.
//
// The function scans all packages that match the patterns for a package-level exported function
// with name `LogTypes`, zero parameters and a single logtypes.Group result.
//
// For example:
// ```
// package foo
//
// import "github.com/panther-labs/panther/internal/log_analysis/log_processor/logtypes"
//
// func LogTypes() logtypes.Group {
//    return logtypes.Must("foo", logtypes.Config{})
// }
// ```
//
func LoadExportedLogTypes(patterns ...string) ([]*types.Package, error) {
	cfg := packages.Config{
		// nolint: staticcheck
		Mode: packages.LoadAllSyntax,
	}
	pkgs, err := packages.Load(&cfg, patterns...)
	if err != nil {
		return nil, err
	}
	var logTypes []*types.Package
	for _, pkg := range pkgs {
		pkgLogTypes := pkg.Imports[pkgPathLogTypes]
		if pkgLogTypes == nil {
			continue
		}
		typGroup := pkgLogTypes.Types.Scope().Lookup(typeNameLogTypesGroup).Type().Underlying().(*types.Interface)
		obj := pkg.Types.Scope().Lookup(exportFuncName)
		if isLogTypesExport(typGroup, obj) {
			logTypes = append(logTypes, pkg.Types)
		}
	}
	return logTypes, nil
}

func isLogTypesExport(typGroup *types.Interface, obj types.Object) bool {
	if obj == nil {
		return false
	}
	fn, ok := obj.(*types.Func)
	if !ok {
		return false
	}
	sig := fn.Type().(*types.Signature)
	if sig.Params().Len() != 0 {
		return false
	}
	if sig.Results().Len() != 1 {
		return false
	}
	result, ok := sig.Results().At(0).Type().(*types.Named)
	if !ok {
		return false
	}
	typResult, ok := result.Underlying().(*types.Interface)
	if !ok {
		return false
	}
	return ok && typResult.String() == typGroup.String()
}

// GenerateInit generates a go file to initialize the registry log types
func GenerateInit(generatedBy string, exportedLogTypes ...*types.Package) ([]byte, error) {
	buf := bytes.Buffer{}
	err := tplRegistryInit.Execute(&buf, struct {
		GeneratedBy      string
		LogTypesPkg      *types.Package
		ExportedLogTypes []*types.Package
	}{
		LogTypesPkg:      types.NewPackage(pkgPathLogTypes, pkgNameLogTypes),
		GeneratedBy:      generatedBy,
		ExportedLogTypes: exportedLogTypes,
	})
	return buf.Bytes(), err
}

var tplRegistryInit = template.Must(template.New("init").Parse(`// Code generated by {{.GeneratedBy}}; DO NOT EDIT 
package registry

import (
	{{ .LogTypesPkg.Path | printf "%q" }}
    // Packages that export log types
{{ range .ExportedLogTypes }}
	{{ .Name }} {{ .Path | printf "%q" }}
{{ end }}
)

func init() {
	// Initialize the registered log types group
	nativeLogTypes = {{.LogTypesPkg.Name}}.MustMerge("registered",
{{ range .ExportedLogTypes }}
       {{.Name}}.LogTypes(),
{{ end }}
	)
}
`))
