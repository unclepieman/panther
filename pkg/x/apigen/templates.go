package main

/**
 * Panther is a Cloud-Native SIEM for the Modern Security Team.
 * Copyright (C) 2020 Panther Labs Inc
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

import (
	"text/template"
)

var (
	funcMap = map[string]interface{}{
		"resolve": resolveType,
	}
	tplLambdaClient = template.Must(template.New("lambdaClient").Funcs(funcMap).Parse(lambdaClientTemplate))
	tplModels       = template.Must(template.New("models").Parse(modelsTemplate))
)

const lambdaClientTemplate = `// Code generated by {{ .Generator }}; DO NOT EDIT.
package {{.Pkg.Name}}

import (
	"context"
	"encoding/json"
	"github.com/aws/aws-sdk-go/aws"
    "github.com/aws/aws-sdk-go/service/lambda/lambdaiface"
	"github.com/aws/aws-sdk-go/service/lambda"
	"github.com/pkg/errors"
	jsoniter "github.com/json-iterator/go"
	{{- range .Imports }}
	{{ .Name }} {{ printf "%q" .Path }}
	{{ end -}}
)

{{ $Client := .API | printf "%sLambdaClient" }}
// {{ $Client }} implements {{.API}} by invoking a Lambda
type {{ $Client }} struct {
	LambdaName string
	LambdaAPI lambdaiface.LambdaAPI
	Validate func(interface{}) error
	JSON jsoniter.API
}

{{ .Payload }} 
{{ $Payload := .API | printf "%sPayload" }}
{{- $pkg := .Pkg -}}

{{ range .Methods }}
{{- if and .Input .Output }}
{{- $Output := .Output | resolve $pkg -}}
{{- $Input := .Input | resolve $pkg }}
func (c *{{ $Client }}) {{.Name}}(ctx context.Context, input *{{ $Input }}) (*{{ $Output }}, error) {
	if input == nil {
		input = &{{ $Input }}{}
	}
	payload := {{ $Payload }}{
		{{.Name}}: input,
	}
	reply := {{ $Output }}{}
	if err := c.invoke(ctx, &payload, &reply); err != nil {
		return nil, err
	}
	return &reply, nil
}
{{ else if .Input }}
{{- $Input := .Input | resolve $pkg }}
func (c *{{ $Client }}) {{.Name}}(ctx context.Context, input *{{ $Input }}) error {
	if input == nil {
		input = &{{ $Input }}{}
	}
	payload := {{ $Payload }}{
		{{.Name}}: input,
	}
	return c.invoke(ctx, &payload, nil)
}
{{ else }}
{{- $Output := .Output | resolve $pkg }}
func (c *{{ $Client }}) {{.Name}}(ctx context.Context) (*{{ $Output }}, error) {
	payload := {{ $Payload }}{
		{{ .Name }}: &struct{}{},
	}
	reply := {{ $Output }}{}
	if err := c.invoke(ctx, &payload, &reply); err != nil {
		return nil, err
	}
	return &reply, nil
}
{{ end }}
{{ end }}

func (c *{{ $Client }}) invoke(ctx context.Context, payload, reply interface{}) error {
	if validate := c.Validate; validate != nil {
		if err := validate(payload); err != nil {
			return err
		}
	}
	marshal := json.Marshal
	if c.JSON != nil {
		marshal = c.JSON.Marshal
	}
	payloadJSON, err := marshal(payload)
	if err != nil {
		return err
	}
	output, err := c.LambdaAPI.InvokeWithContext(ctx, &lambda.InvokeInput{
		FunctionName: aws.String(c.LambdaName),
		Payload: payloadJSON,
	})
	if err != nil {
		return err
	}
	unmarshal := json.Unmarshal
	if c.JSON != nil {
		unmarshal = c.JSON.Unmarshal
	}
	if output.FunctionError != nil {
		invokeErr := struct {
			Message string "json:\"errorMessage\""
		}{}
		if err := unmarshal(output.Payload, &invokeErr); err != nil {
			return err
		}
		return errors.Errorf("lambda %q execution failed: %s", c.LambdaName, invokeErr.Message)
	}
	if reply == nil {
		return nil
	}
	return unmarshal(output.Payload, reply)
}

`
const modelsTemplate = `// Code generated by {{ .Generator }}; DO NOT EDIT.
// package {{.Pkg.Name}} documents {{.Pkg.Path}}.{{.API}}
package {{.Pkg.Name}}

{{- range .Imports }}
import {{ printf "%q" .Path }}
{{- end }}

// {{.API}} available endpoints
type {{.API}} interface {
{{- range .Methods }}
{{- if and .Input .Output }}
	{{.Name}}(input {{.Name}}Input) ({{.Name}}Response, error)
{{- else if .Input }}
	{{.Name}}(input {{.Name}}Input) error
{{- else }}
	{{.Name}}() ({{.Name}}Response, error)
{{- end }}
{{ end -}}
}

// Models for {{.API}}

// {{.API}}Payload is the payload for calls to {{.API}} endpoints.
type {{.API}}Payload struct {
{{- range .Methods }}
{{- if .Input }}
	{{ .Name }} *{{ .Name }}Input
{{- else }}
	{{ .Name }} *struct{}
{{- end -}}
{{- end }}
}

{{ .Models }}
`
